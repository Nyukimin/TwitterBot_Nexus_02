diff --git a/reply_bot/post_reply.py b/reply_bot/post_reply.py
index feb702f..b6a8799 100644
--- a/reply_bot/post_reply.py
+++ b/reply_bot/post_reply.py
@@ -8,13 +8,15 @@ from selenium.webdriver.common.by import By
 from selenium.webdriver.common.keys import Keys
 from selenium.webdriver.support.ui import WebDriverWait
 from selenium.webdriver.support import expected_conditions as EC
+from selenium import webdriver
 
 from .utils import setup_driver
+from .config import POST_INTERVAL_SECONDS
 
 # ログ設定
 logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
 
-def main_process(input_csv: str, dry_run: bool = True, limit: int | None = None):
+def main_process(driver: webdriver.Chrome, input_csv: str, dry_run: bool = True, limit: int | None = None, interval: int = 15):
     """
     CSVを読み込み、各リプライに対してページアクセスを1回に最適化し、
     「いいね」と「返信」を行います。
@@ -42,8 +44,8 @@ def main_process(input_csv: str, dry_run: bool = True, limit: int | None = None)
         logging.info("投稿対象の返信が見つかりませんでした。")
         return
         
-    driver = setup_driver(headless=False)
     if not driver:
+        logging.error("有効なWebDriverインスタンスが渡されませんでした。")
         return
 
     try:
@@ -59,19 +61,38 @@ def main_process(input_csv: str, dry_run: bool = True, limit: int | None = None)
             tweet_url = f"https://x.com/any/status/{tweet_id}"
             logging.info(f"ツイートページにアクセス中: {tweet_url}")
             driver.get(tweet_url)
-            wait = WebDriverWait(driver, 15)
+            wait = WebDriverWait(driver, 20) # 待機時間を20秒に延長
+
+            # ★ 新規追加: ツイート本文が表示されるまで待機することで、ページの読み込みを確実にする
+            try:
+                logging.info("ツイート本文が表示されるまで待機します...")
+                wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '[data-testid="tweetText"]')))
+                logging.info("ツイート本文の表示を確認しました。")
+            except Exception as e:
+                logging.warning(f"ツイート本文の読み込み中にタイムアウトしました。処理を続行しますが、失敗する可能性があります。: {e}")
 
             # 2. 「いいね」処理
             if like_num == 0:
                 try:
-                    like_button_selector = '[data-testid="like"]'
-                    like_button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, like_button_selector)))
+                    # SVGアイコンのpathデータという不変の要素で「いいね」ボタンを特定する
+                    logging.info("SVG pathデータに基づいて「いいね」ボタンを特定します...")
+                    
+                    # ハートアイコンのSVG pathデータ（一部）
+                    like_icon_path_data = "M12 21.638h-.014C9.403 21.59 1.95 14.856 1.95 8.478"
+                    
+                    # このpathデータを持つsvgを探し、その親のdiv(role=button)を取得するXPath
+                    like_button_xpath = f"//div[@role='button' and .//path[contains(@d, '{like_icon_path_data}')]]"
+
+                    like_button = wait.until(EC.element_to_be_clickable((By.XPATH, like_button_xpath)))
+                    logging.info("「いいね」ボタンを特定しました。")
+
                     if dry_run:
                         logging.info(f"[DRY RUN] tweet_id: {tweet_id} に「いいね」をします。")
                     else:
                         logging.info(f"tweet_id: {tweet_id} に「いいね」をします。")
                         driver.execute_script("arguments[0].click();", like_button)
                         time.sleep(1)
+
                 except Exception as e:
                     logging.error(f"tweet_id: {tweet_id} の「いいね」中にエラーが発生しました: {e}")
             else:
@@ -88,29 +109,37 @@ def main_process(input_csv: str, dry_run: bool = True, limit: int | None = None)
                     else:
                         logging.info(f"tweet_id: {tweet_id} に返信します...")
                         
-                        # 確実なフォーカスとペースト
-                        reply_input.click() 
-                        time.sleep(0.5)
-                        pyperclip.copy(generated_reply)
+                        # クリップボード経由の操作
+                        logging.info("返信ボックスにフォーカスを試みます。")
+                        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, reply_input_selector)))
+                        driver.execute_script("arguments[0].focus(); arguments[0].click();", reply_input)
+                        time.sleep(1) # フォーカス後の待機
+
+                        logging.info("返信内容をクリップボード経由で貼り付けます。")
+                        
+                        final_reply_text = generated_reply.replace('<br>', '\n')
+                        pyperclip.copy(final_reply_text)
+                        
                         reply_input.send_keys(Keys.CONTROL, 'v')
                         time.sleep(0.5)
 
                         logging.info("Ctrl+Enterで返信を投稿します...")
                         reply_input.send_keys(Keys.CONTROL, Keys.ENTER)
                         
-                        logging.info("返信を投稿しました。処理が完了するまで10秒待機します...")
-                        time.sleep(10)
+                        logging.info("返信を投稿しました。")
+                        # 投稿後の待機はいいねの後に入れるため、ここでは短くする
+                        time.sleep(2) 
+
                 except Exception as e:
                     logging.error(f"tweet_id: {tweet_id} への返信中にエラーが発生しました: {e}")
             else:
                 logging.info(f"tweet_id: {tweet_id} は自分のスレッドではないため、返信をスキップします。")
-            
-            logging.info("次の処理までのクールダウン (30秒)")
-            time.sleep(30)
 
-    finally:
-        logging.info("全ての処理が完了しました。WebDriverを終了します。")
-        driver.quit()
+            logging.info(f"次の処理までのクールダウン ({interval}秒)")
+            time.sleep(interval)
+    except Exception as e:
+        logging.error(f"投稿処理中に予期せぬエラーが発生しました: {e}", exc_info=True)
+    logging.info("投稿処理のサイクルが完了しました。")
 
 
 if __name__ == '__main__':
@@ -118,10 +147,24 @@ if __name__ == '__main__':
     parser.add_argument('input_csv', type=str, help='入力CSVファイルのパス (例: output/generated_replies_....csv)')
     parser.add_argument('--live-run', action='store_true', help='このフラグを立てると、実際に投稿やいいねを行います（ドライランを無効化）。')
     parser.add_argument('--limit', type=int, default=None, help='処理するツイートの最大数を指定します。')
+    parser.add_argument('--interval', type=int, default=None, help=f'投稿間の待機時間（秒）。指定しない場合はconfig.pyの値({POST_INTERVAL_SECONDS}秒)が使われます。')
     
     args = parser.parse_args()
     
     # --live-run フラグがなければ dry_run は True
     is_dry_run = not args.live_run
+
+    # インターバル時間が引数で指定されていればそれを使い、なければconfigから取得
+    interval_to_use = args.interval if args.interval is not None else POST_INTERVAL_SECONDS
     
-    main_process(args.input_csv, dry_run=is_dry_run, limit=args.limit) 
\ No newline at end of file
+    # 単体実行時のみ、driverの起動と終了をここで行う
+    driver = None
+    try:
+        # ユーザーの記憶に基づき、デバッグ中はFalseを維持 [[memory:2213753]]
+        driver = setup_driver(headless=False)
+        if driver:
+            main_process(driver, args.input_csv, dry_run=is_dry_run, limit=args.limit, interval=interval_to_use)
+    finally:
+        if driver:
+            driver.quit()
+            logging.info("Selenium WebDriverを終了しました。") 
\ No newline at end of file
